bool insert(){
	1) VAI ATE A POSICAO e verifica se ja existe {RETRIEVE} ????????????/
		-true: Altera o conteudo, retorna false
		-false: Calcula a posicao (utilizando o HASH e MOD),push_front(conteudo), retorna true,
	3) Incrementa m_count
	4) metodo full.
}

bool insert(hash_key, conteudo){              ???????????/ COMPARACAO DE CONTEUDO COM O QUE???
	int pos = hash_to_pos(hash_key)
	vetor[pos].push_front(conteudo)
	m_count++;
}


void clear(){
		1) delete[]vetor[i]
		2)
	}

void empty(){
	1) verifica se m_count == 0
		-true: retorna true
		-false: retorna false	
}

size_t size(){
	1) retorna m_count
}

size_T count(){
	1) calcula a posicao (utilizando o HASH e MOD)
	2) size(foward_list) da posicao do vetor[posicao]
}

rehash(){
	1) Procura o proximo primo em relacao a m_size
	2) cria um novo vetor copia baseado no tamanho de 1)
	3) para cada elemento do vetor original, utilizando a chabe de cada elemento, o inserimos no vetor copia
	4) clear do vetor original
	5) vetor original aponta para o copia
	6) deleta-se o copia
}
void rehash(){
	size_t new_size = next_prime(size);
	std :: forward_list < Entry > *aux = new std :: forward_list[new_size]
	for(i=0;i<size, i++){
		iterator = vetor[i];
		while(iterator end != nullptr){
			aux.insert(iterator.chave, iterator.data);
			iterator++;
		}
	}
	clear();
	m_data_table = aux;
	delete[] aux;
}